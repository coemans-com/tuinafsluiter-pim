
export const MIGRATION_SCRIPT = `-- SECURITY UPGRADE MIGRATION SCRIPT
-- V4: FIX "NULL Scan Error" & ENFORCE UNIQUE SKUs

create extension if not exists pgcrypto;

-- 1. Ensure Tables Exist
create table if not exists products ( id text primary key, sku text not null, name text not null, type text not null, purchase_cost numeric default 0, prices jsonb default '[]'::jsonb, teamleader_id text, needs_sync boolean default true, last_sync timestamptz, last_edited timestamptz );
alter table products add column if not exists last_edited timestamptz;
create table if not exists bom_entries ( id bigint generated by default as identity primary key, parent_id text references products(id) on delete cascade, component_id text references products(id), quantity numeric not null );
create table if not exists users ( id text primary key, email text unique not null, name text not null, role text not null );
create table if not exists app_logs ( id bigint generated by default as identity primary key, type text not null, message text not null, details jsonb, user_id text, user_name text, created_at timestamptz default now() );
create table if not exists integrations ( service text primary key, settings jsonb default '{}'::jsonb, updated_at timestamptz default now() );

-- 2. CRITICAL FIX: Convert NULL tokens to Empty Strings
UPDATE auth.users SET confirmation_token = '' WHERE confirmation_token IS NULL;
UPDATE auth.users SET recovery_token = '' WHERE recovery_token IS NULL;
UPDATE auth.users SET email_change_token_new = '' WHERE email_change_token_new IS NULL;
UPDATE auth.users SET email_change_token_current = '' WHERE email_change_token_current IS NULL;
UPDATE auth.users SET phone_change_token = '' WHERE phone_change_token IS NULL;

-- 3. CRITICAL FIX: Ensure Instance ID is correct
DO $$
DECLARE
  target_instance_id uuid;
BEGIN
  SELECT instance_id INTO target_instance_id FROM auth.users WHERE instance_id IS NOT NULL LIMIT 1;
  IF target_instance_id IS NULL THEN target_instance_id := '00000000-0000-0000-0000-000000000000'; END IF;
  UPDATE auth.users SET instance_id = target_instance_id WHERE instance_id IS NULL;
END $$;

-- 4. Sync public.users with auth.users (Insert missing users)
do $$
declare
  user_record record;
  new_uid uuid;
  target_instance_id uuid;
begin
  SELECT instance_id INTO target_instance_id FROM auth.users LIMIT 1;
  IF target_instance_id IS NULL THEN target_instance_id := '00000000-0000-0000-0000-000000000000'; END IF;

  for user_record in select * from public.users loop
    if not exists (select 1 from auth.users where email = user_record.email) then
      new_uid := gen_random_uuid();
      insert into auth.users (
        id, instance_id, aud, role, email, encrypted_password, email_confirmed_at, 
        raw_app_meta_data, raw_user_meta_data, created_at, updated_at,
        confirmation_token, recovery_token, email_change_token_new, email_change_token_current, phone_change_token
      )
      values (
        new_uid, target_instance_id, 'authenticated', 'authenticated', user_record.email, crypt(user_record.password, gen_salt('bf')), now(), 
        '{"provider":"email","providers":["email"]}', jsonb_build_object('name', user_record.name, 'role', user_record.role), now(), now(),
        '', '', '', '', ''
      );
      update public.users set id = new_uid::text where email = user_record.email;
    end if;
  end loop;
end $$;

-- 5. REPAIR IDENTITIES (Aggressive Fix)
do $$
declare
  au record;
begin
  for au in select * from auth.users loop
    delete from auth.identities where user_id = au.id;
    insert into auth.identities (id, user_id, identity_data, provider, provider_id, last_sign_in_at, created_at, updated_at)
    values (gen_random_uuid(), au.id, jsonb_build_object('sub', au.id, 'email', au.email), 'email', au.id::text, now(), now(), now());
  end loop;
end $$;

-- 6. Cleanup
alter table public.users drop column if exists password;

-- 7. Admin Functions
create or replace function create_user_by_admin(new_email text, new_password text, new_name text, new_role text) returns void language plpgsql security definer as $$
declare
  new_id uuid;
  target_instance_id uuid;
begin
  new_id := gen_random_uuid();
  SELECT instance_id INTO target_instance_id FROM auth.users LIMIT 1;
  IF target_instance_id IS NULL THEN target_instance_id := '00000000-0000-0000-0000-000000000000'; END IF;
  
  insert into auth.users (
    id, instance_id, aud, role, email, encrypted_password, email_confirmed_at, 
    raw_app_meta_data, raw_user_meta_data, created_at, updated_at,
    confirmation_token, recovery_token, email_change_token_new, email_change_token_current, phone_change_token
  )
  values (
    new_id, target_instance_id, 'authenticated', 'authenticated', new_email, crypt(new_password, gen_salt('bf')), now(), 
    '{"provider":"email","providers":["email"]}', jsonb_build_object('name', new_name, 'role', new_role), now(), now(),
    '', '', '', '', ''
  );
  
  insert into auth.identities (id, user_id, identity_data, provider, provider_id, last_sign_in_at, created_at, updated_at)
  values (gen_random_uuid(), new_id, jsonb_build_object('sub', new_id, 'email', new_email), 'email', new_id::text, now(), now(), now());

  insert into public.users (id, email, name, role) values (new_id, new_email, new_name, new_role);
end;
$$;

create or replace function reset_password_by_admin(target_email text, new_password text) returns void language plpgsql security definer as $$
begin
  update auth.users set encrypted_password = crypt(new_password, gen_salt('bf')) where email = target_email;
end;
$$;

create or replace function delete_user_by_admin(target_id uuid) returns void language plpgsql security definer as $$
begin
  delete from public.users where id = target_id::text;
  delete from auth.users where id = target_id;
  delete from auth.identities where user_id = target_id;
end;
$$;

-- 8. Permissions & RLS
grant usage on schema public to postgres, anon, authenticated, service_role;
grant all privileges on all tables in schema public to postgres, anon, authenticated, service_role;
grant all privileges on all functions in schema public to postgres, anon, authenticated, service_role;

alter table products enable row level security; 
drop policy if exists "Public" on products; 
create policy "Public" on products for all using (true);

alter table bom_entries enable row level security; 
drop policy if exists "Public" on bom_entries;
create policy "Public" on bom_entries for all using (true);

alter table users enable row level security; 
drop policy if exists "Public" on users;
create policy "Public" on users for all using (true);

alter table app_logs enable row level security; 
drop policy if exists "Public" on app_logs;
create policy "Public" on app_logs for all using (true);

alter table integrations enable row level security; 
drop policy if exists "Public" on integrations;
create policy "Public" on integrations for all using (true);

-- 9. Unique SKU Constraint (Safe Application)
DO $$
BEGIN
  -- A. Handle existing duplicates (append random suffix to keep them but make them unique)
  -- This prevents the UNIQUE constraint from failing if bad data exists
  UPDATE products p
  SET sku = p.sku || '_dup_' || substr(md5(random()::text), 1, 4)
  WHERE p.id IN (
    SELECT id FROM (
      SELECT id, ROW_NUMBER() OVER (PARTITION BY sku ORDER BY last_edited DESC) as rn
      FROM products
    ) t WHERE rn > 1
  );

  -- B. Apply the constraint
  IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'products_sku_key') THEN
    ALTER TABLE products ADD CONSTRAINT products_sku_key UNIQUE (sku);
  END IF;
END $$;
`;